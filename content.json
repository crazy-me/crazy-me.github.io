{"meta":{"title":"fixblog-侯爽","subtitle":"","description":"","author":"John Doe","url":"http://www.fixblog.cn","root":"/"},"pages":[{"title":"友情链接","date":"2021-02-23T10:41:37.592Z","updated":"2021-02-23T09:10:36.360Z","comments":true,"path":"links/index.html","permalink":"http://www.fixblog.cn/links/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-02-23T10:40:12.395Z","updated":"2021-02-23T09:10:36.360Z","comments":false,"path":"categories/index.html","permalink":"http://www.fixblog.cn/categories/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2021-02-23T10:37:54.689Z","updated":"2021-02-23T09:10:36.360Z","comments":false,"path":"repository/index.html","permalink":"http://www.fixblog.cn/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-02-23T10:44:32.085Z","updated":"2021-02-23T09:10:36.360Z","comments":false,"path":"tags/index.html","permalink":"http://www.fixblog.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"redis的常用指令及介绍","slug":"redis-basic","date":"2019-02-24T06:43:03.000Z","updated":"2021-02-24T06:45:20.903Z","comments":true,"path":"2019/02/24/redis-basic/","link":"","permalink":"http://www.fixblog.cn/2019/02/24/redis-basic/","excerpt":"","text":"介绍 由于用户量增大，请求数量随之增大数据压力过大 多台服务器之间数据不同步 多台服务器之间的锁已经不存在互斥性了 Redis是NoSql 是一款非关系型数据库 Redis提供了多种持久化机制性能可达到110000/s读取及81000/s的写入 Redis提供了主从 哨兵以及集群的搭建方式，可方便横向及垂直扩展 安装123456789101112131415# docker-compose.yml command 代表执行命令version: &quot;3.1&quot;services: redis: restart: always image: daocloud.io/library/redis:5.0.9 container_name: redis environment: - TZ=Asia/Shanghai ports: - 6379:6379 volumes: - ./conf/redis.conf:/usr/local/redis/redis.conf # 映射配置文件 - ./data:/data # 映射RDB持久化文件到容器外 command: [&quot;redis-server&quot;,&quot;/usr/local/redis/redis.conf&quot;] # 容器启动时启动redis并加载配置文件 Redis基本存储数据的结构 123451.key-string：一个key对应一个值2.key-hash：一个key对应一个Map3.key-list：一个key对应一个列表可以重复 存取有序4.key-set：一个key对应一个集合无序不可重复5.key-zset：一个key对应一个有序集合不可重复 Redis特殊存储数据结构 1231.HyperLoglog：用来计算近似值的2.GEO：地理位置3.BIT：一般存储的也是字符串，存储的是一个byte[] String 常用命令 123456789101112131415# 添加值set key value# 取值get key# 批量操作mset key value key value... #每组key value 以空格分开mget key key...# 设置值并指定声明周期setex key second value# 设置值 如果key存在则什么都不做如果不存在则和set一样setnx key value# 在key对应的value后追加内容append key value# 查看value字符串的长度strlen key 1234567# 自增命令(自增1)incr key# 自减命令(自减1)decr key# 自增或自减指定数量incrby key incrementdecrby key increment hash 常用命令 1234567# 存储数据hset key field value# 获取数据hget key field# 批量操作hmset key field value file value...hmget key field field... 12# 自增(指定自增的值)hincrby key field increment 1234567891011121314# 设置值(如果key-field存在则什么都不做否则正常添加)hsetnx key field value# 检查field是否存在hexists key field# 删除key对应的某一个field,可删除多个fieldhdel key field field...# 获取当前hash结构中的全部field和valuehgetall key# 获取当前hash结构中的全部fieldhkeys key# 获取当前hash结构中的全部valuehvals key# 获取当前hash结构中field的数量hlen key list 常用命令 123456789# 存储数据(从左侧插入 可批量)lpush key value value...# 存储数据(从右侧插入 可批量)rpush key value value...# 存储数据(如果key不存在,什么都不做,如果key存在 但不是list结构 什么都不做 没有批量操作)lpushx key valuerpushx key value# 存储数据(在存储数据时指定索引位置,会覆盖之前索引位置的数据 如果指定的索引超出列表的长度会失败)lset key index value 123456789# 弹栈方式获取数据(左侧弹出 右侧弹出)lpop keyrpop key# 获取指定索引范围的数据(start 从0开始 stop输入-1 代表最后一个 -2代表倒数第二个)lrange key start stop# 获取指定索引位置的数据lindex key index# 获取整个列表的长度llen key 12345678# 删除列表中的数据(删除列表中的count个value值 count大于0 从左向右删除 count小于0从右向左删除 count=0 删除全部的数据)lrem key count value# 保留列表中的数据(保留指定范围的数据，超出这个返回的数据会被移除)ltrim key start stop# 将一个列表中最后一个数据插入到另一个列表的头部位置rpoplpush list1 list2 set 常用命令 123456# 存储数据sadd key member member...# 获取全部数据smembers key# 随机获取一个数据(count 默认为1代表弹出的数量)spop key count 123456# 交集(取多个集合的交集)sinter set1 set2...# 并集(获取全部集合中的数据)sunion set1 set2...# 差集(获取多个集合中不一样的数据)sdiff set1 set2... 1234# 删除数据srem key member member...# 查看当前的集合中是否包含这个值sismember key member zset 常用命令 1234# 存储数据(score必须是数值 member不可重复)zadd key score member member...# 修改member的分(如果member是存在于key中 正常增加分数 如果不存在则相当于zadd)zincrby key increment member 12345678910111213141516# 查看指定member的分数zscore key member# 获取zset中的数量zcard key# 根据score的范围查看member数量zcount key min max# 删除zset中的成员zrem key member member...# 根据分数从小到大排序获取指定范围的数据(withscores如果添加这个参数 那么会返回member对应的分数)zrange key start stop [withscores]# 根据分数从大到小排序获取指定范围的数据(withscores如果添加这个参数 那么会返回member对应的分数)zrevrange key start stop [withscores]# 根据分数的范围获取数据member(withscores代表同时返回score，limit和mysql一样)zrangebyscore key min max [withscores][limit offset count]# 根据分数的范围获取数据member(withscores代表同时返回score，limit和mysql一样)zrangebyscore key max min [withscores][limit offset count] key 常用命令 123456# 查看redis中全部的key(pattern: * | xxx* | *xxx)keys pattern# 查看某一个key是否存在exists key# 删除keydel key key... 1234567891011121314# 设置key的生成时间(单位秒 和毫秒 设置还能活多久)expire key secondpexpire key milliseconds# 设置key的生存时间(单位秒和毫秒 设置能活到什么时候)expireat key timestamppexpireat key milliseconds# 查看key 剩余生存时间(单位秒 返回-2 &quot;key不存在&quot; -1 &quot;当前key没有设置时间&quot;)ttl key# 查看key 剩余生存时间(单位毫秒 返回-2 &quot;key不存在&quot; -1 &quot;当前key没有设置时间&quot;)pttl key# 移除key的生存时间(返回 1 &quot;移除成功&quot; 0 &quot;不存在或key不存在&quot;)persist key 1234# 选择操作的库select 0~15# 移动key到另一个库move key db 库的常用命令 12345678910# 清空当前所在的库flushdb# 清空全部的库flushall# 查看当前库中有多少keydbsize# 查看最后一次操作时间(返回时间戳)lastsave# 实时监听Redis服务接收到的命令(用于调试)monitor RDB RDB持久化是redis默认的方式 速度比较快，以二进制文件存储 RDB持久化无法保证数据的绝对安全 123456789101112# RDB持久化配置# save 配置代表RDB执行的时机save 900 1 # 900秒之内有1个key改变了就执行RDB持久化save 300 10 # 300秒之内有10个key改变了就执行RDB持久化save 60 10000 # 60秒之内有10000个key改变了就执行RDB持久化# 开启RDB持久化的压缩rdbcompression yes#RDB持久化文件的名称dbfilename dump.rdb AOF AOF持久化机制默认是关闭的 官方推荐同时开启RDB和AOF持久化 保证数据安全。 AOF持久化的速度相对较慢，它存储的是一个文本文件，到了后期文件会比较大，传输困难。 1234567# AOF持久化配置appendonly no # 开启AOF持久化 默认关闭appendfilename &quot;appendonly.aof&quot; # AOF文件的名称# AOF持久化执行时机(以下三个配置只能三选一)appendfsync always # 每执行一次写操作，立即持久化到AOF文件中，性能较低appendfsync everysec # 每秒执行一次持久化（推荐）appendfsync no # 会根据操作系统不同，环境不同 在一定时间内执行一次持久化（不安全） 事物 Redis事物：一次事物操作，该成功的成功，该失败的失败 先开启事物 执行一系列的命令 但是这些命令不会立即执行 它会被放在一个队列中，如果你执行事物 这个队列中的命令全部执行，如果取消了事物，一个队列中的命令全部作废。 123456789# Redis 事物操作 1. 开启事物：mnlti 2. 输入要执行的命令：会被放入到一个队列中 3. 执行事物：exec 4. 取消事物：discard# Redis的事物想发挥它的功能 需要配合watch(监听机制使用) 在开启事物之前，先通过watch命令去监听一个或多个key,在开启事物之后如果有其他客户端修改了监听的key 那么事物会自动取消。 如果执行了事物，或者取消了事物，watch监听自动消除，不需要手动执行unwatch。 主从 单机版存在读写瓶颈的问题 master：读/写 slave：读 1234567891011121314151617181920212223242526272829303132333435363738394041424344# docker-compose.ymlversion: &quot;3.1&quot;services: redis1: restart: always image: daocloud.io/library/redis:5.0.9 container_name: redis1 environment: - TZ=Asia/Shanghai ports: - 6001:6379 volumes: - ./conf/redis1.conf:/usr/local/redis/redis.conf # 映射配置文件 - ./data:/data # 映射RDB持久化文件到容器外 command: [&quot;redis-server&quot;,&quot;/usr/local/redis/redis.conf&quot;] redis2: restart: always image: daocloud.io/library/redis:5.0.9 container_name: redis2 environment: - TZ=Asia/Shanghai ports: - 6002:6379 volumes: - ./conf/redis2.conf:/usr/local/redis/redis.conf # 映射配置文件 - ./data:/data # 映射RDB持久化文件到容器外 links: # 配置能找到master - redis1:master command: [&quot;redis-server&quot;,&quot;/usr/local/redis/redis.conf&quot;] redis3: restart: always image: daocloud.io/library/redis:5.0.9 container_name: redis3 environment: - TZ=Asia/Shanghai ports: - 6003:6379 volumes: - ./conf/redis3.conf:/usr/local/redis/redis.conf # 映射配置文件 - ./data:/data # 映射RDB持久化文件到容器外 links: - redis1:master command: [&quot;redis-server&quot;,&quot;/usr/local/redis/redis.conf&quot;] 12# redis2 redis3从节点配置指定master节点# replicaof &lt;masterip&gt; &lt;masterport&gt; 哨兵 哨兵 解决在master节点宕机时导致无法写问题 12345678910111213141516171819202122232425262728293031323334353637383940414243# 哨兵模式docker-compose.ymlversion: &quot;3.1&quot;services: redis1: restart: always image: daocloud.io/library/redis:5.0.9 container_name: redis1 environment: - TZ=Asia/Shanghai ports: - 6001:6379 volumes: - ./conf/redis1.conf:/usr/local/redis/redis.conf - ./conf/sentinel1.conf:/data/sentinel.conf command: [&quot;redis-server&quot;,&quot;/usr/local/redis/redis.conf&quot;] redis2: restart: always image: daocloud.io/library/redis:5.0.9 container_name: redis2 environment: - TZ=Asia/Shanghai ports: - 6002:6379 volumes: - ./conf/redis2.conf:/usr/local/redis/redis.conf - ./conf/sentinel2.conf:/data/sentinel.conf links: - redis1:master command: [&quot;redis-server&quot;,&quot;/usr/local/redis/redis.conf&quot;] redis3: restart: always image: daocloud.io/library/redis:5.0.9 container_name: redis3 environment: - TZ=Asia/Shanghai ports: - 6003:6379 volumes: - ./conf/redis3.conf:/usr/local/redis/redis.conf - ./conf/sentinel3.conf:/data/sentinel.conf links: - redis1:master command: [&quot;redis-server&quot;,&quot;/usr/local/redis/redis.conf&quot;] 12345678# 哨兵配置文件 sentinel.confdaemonize yes # 后台启动# 指定Master节点的IP和端口(主)sentinel monitor master(主节点名称) localhost(ip或别名) 6379(端口) 2(从节点数量)# 指定slave节点的IP和端口(从)sentinel monitor master master 6379 2# 哨兵 每隔多久监听一次redis架构默认30秒sentinel down-after-milliseconds master 30000 12# 哨兵配置数据卷- ./conf/sentinel1.conf:/data/sentinel.conf 12# 启动哨兵sentinelredis-sentinel sentinel.conf 集群 Redis集群在保证主从加哨兵的基本功能之外，还能够提升Redis的存储数据的能力。 Redis集群是无中心化的，有一个ping-pang机制 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576# docker-compose.ymlversion: &quot;3.1&quot;services: redis1: image: daocloud.io/library/redis:5.0.9 restart: always container_name: redis1 environment: - TZ=Asia/Shanghai ports: - 7001:7001 - 17001:17001 volumes: - ./conf/redis1.conf:/usr/local/redis/redis.conf command: [&quot;redis-server&quot;,&quot;/usr/local/redis/redis.conf&quot;] redis2: image: daocloud.io/library/redis:5.0.9 restart: always container_name: redis2 environment: - TZ=Asia/Shanghai ports: - 7002:7002 - 17002:17002 volumes: - ./conf/redis2.conf:/usr/local/redis/redis.conf command: [&quot;redis-server&quot;,&quot;/usr/local/redis/redis.conf&quot;] redis3: image: daocloud.io/library/redis:5.0.9 restart: always container_name: redis3 environment: - TZ=Asia/Shanghai ports: - 7003:7003 - 17003:17003 volumes: - ./conf/redis3.conf:/usr/local/redis/redis.conf command: [&quot;redis-server&quot;,&quot;/usr/local/redis/redis.conf&quot;] redis4: image: daocloud.io/library/redis:5.0.9 restart: always container_name: redis4 environment: - TZ=Asia/Shanghai ports: - 7004:7004 - 17004:17004 volumes: - ./conf/redis4.conf:/usr/local/redis/redis.conf command: [&quot;redis-server&quot;,&quot;/usr/local/redis/redis.conf&quot;] redis5: image: daocloud.io/library/redis:5.0.9 restart: always container_name: redis5 environment: - TZ=Asia/Shanghai ports: - 7005:7005 - 17005:17005 volumes: - ./conf/redis5.conf:/usr/local/redis/redis.conf command: [&quot;redis-server&quot;,&quot;/usr/local/redis/redis.conf&quot;] redis6: image: daocloud.io/library/redis:5.0.9 restart: always container_name: redis6 environment: - TZ=Asia/Shanghai ports: - 7006:7006 - 17006:17006 volumes: - ./conf/redis6.conf:/usr/local/redis/redis.conf command: [&quot;redis-server&quot;,&quot;/usr/local/redis/redis.conf&quot;] 12345678910111213# 创建conf文件及 redis.conf# 指定Redis的端口号port 7001# 开启Redis集群cluster-enabled yes# 集群信息的文件cluster-config-file nodes-7001.conf# 集群的对外IP地址cluster-announce-ip 192.168.1.1# 集群的对外端口cluster-announce-port 7001# 集群的对外总线端口cluster-announce-bus-port 1234567# 启动Redis集群(6个节点)docker-compose up -d # 随便进入一个容器内 使用redis-cli管理集群 --cluster-replicas 表示每个主节点下有几个从节点redis-cli --cluster create 192.168.1.1:7001 192.168.1.1:7002 192.168.1.1:7003 192.168.1.1:7004 192.168.1.1:7005 192.168.1.1:7006 --cluster-replicas 1# 客户端不能使用localhost的方式连接集群需指定IP:端口 （-c参数表示连接成功后在各个节点之间来回切换）redis-cli -h 192.168.1.1 -p 7001 -c 删除策略 Redis key的生存时间过期后不会马上删除而是有删除策略 定期删除 Redis每隔一段时间就会去查看设置了过期时间的key，会在100ms的间隔中默认查看3个key。 惰性删除 当查询一个已经过期的key时，Redis会先查看当前key的生存时间是否已经到了，直接删除当前key并给用户返回一个空值。 淘汰机制 在Redis内存已经满的时候，添加了一个新的数据就会执行淘汰机制 volatile-lru： 在内存不足时，Redis会在设置过生存时间的key中删除一个最近最少使用的key。 allkeys-lru： 在内存不足时，Redis会在全部的key中删除一个最近最少使用的key。 volatile-lfu： 在内存不足时，Redis会在设置过生存时间的key中删除一个最近最少频次使用的key。 allkeys-lfu： 在内存不足时，Redis会在全部的key中删除一个最近最少频次使用的key。 volatile-random： 在内存不足时，Redis会在设置过生存时间的key中随机删除一个key。 allkeys-random： 在内存不足时，Redis会在全部的key中随机删除一个key。 volatile-ttl： 在内存不足时，Redis会在设置过生存时间的key中删除一个剩余生存时间最少的一个key。 no eviction：（默认） 在内存不足时，直接报错 指定淘汰机制的方式：maxmemory-policy 具体策略 设置Redis的最大内存：maxmemory 字节大小为单位的数值","categories":[],"tags":[{"name":"redis","slug":"redis","permalink":"http://www.fixblog.cn/tags/redis/"}]},{"title":"Go语言defer的那些事儿","slug":"go-defer","date":"2019-02-03T03:13:23.000Z","updated":"2021-02-24T06:58:33.708Z","comments":true,"path":"2019/02/03/go-defer/","link":"","permalink":"http://www.fixblog.cn/2019/02/03/go-defer/","excerpt":"","text":"defer目录 defer执行时机 defer执行顺序 defer与return谁先谁后 函数包含多个Panic，defer中recover处理那个Panic 函数返回值遇到defer defer遇到Panic defer遇到Panic，但是并不捕获异常的情况 defer遇到Panic，并捕获异常 练习：defer面试题 闲聊 欢迎加入我的公众号【迈莫coding】 一起pk大厂 defer执行时机 return 语句执行完之后，如果有 defer 语句，再执行 defer 语句 发生 Panic ，也会触发 defer 执行 defer执行顺序 多个defer出现时，会以”先进后出，后进先出”的规则来执行，类似于数据结构中栈的执行顺序. 示例： 12345678910111213141516package main import &quot;fmt&quot;func main() &#123; defer func()&#123; fmt.Println(&quot;A&quot;) &#125;() defer func()&#123; fmt.Println(&quot;B&quot;) &#125; defer func()&#123; fmt.Println(&quot;C&quot;) &#125;&#125;复制代码 结果： 1234CBA复制代码 defer与return谁先谁后示例代码 12345678910111213141516171819202122package main import &quot;fmt&quot;func deferFunc() &#123; fmt.Println(&quot;defer func&quot;)&#125;func returnFunc() int &#123; fmt.Println(&quot;return func&quot;) return 1&#125;func returnAndDefer() int &#123; defer deferFunc() return returnFunc()&#125;func main() &#123; returnAndDefer()&#125;复制代码 结果 123return funcdefer func复制代码 结论 12一个函数中即有return语句，也有defer语句，先执行return语句，后执行defer语句复制代码 函数包含多个Panic，defer中recover处理那个Panic示例 123456789101112131415161718package mainimport &quot;fmt&quot;func main() &#123; defer func() &#123; if err := recover(); err != nil &#123; fmt.Println(err) &#125;else &#123; fmt.Println(&quot;fail&quot;) &#125; &#125;() defer func() &#123; panic(&quot;defer panic&quot;) &#125;() panic(&quot;main panic&quot;)&#125;复制代码 结果 12defer panic复制代码 结论 12只有最后一个panic，可以被recover捕获到.复制代码 函数返回值遇到defer示例 123456789101112131415package mainimport &quot;fmt&quot;func deferFunc() (t int) &#123; // t初始化为0，并且作用域为该函数全域 defer func() &#123; t = t * 10 &#125;() return 1&#125;func main() &#123; fmt.Println(deferFunc())&#125;复制代码 结果 1210 复制代码 结论 1234当调用deferFunc()函数时，本应该返回值1，但函数中还有defer语句，所以在return语句之后，又被defer的匿名函数func函数执行，所以t=t*10被执行。因此返回值为10.复制代码 defer遇到Panicdefer遇到Panic，但是并不捕获异常的情况示例 12345678910111213141516171819package mainimport &quot;fmt&quot;func defer_panic() &#123; defer func() &#123; fmt.Println(&quot;defer: panic() 执行1&quot;) &#125;() defer func() &#123; fmt.Println(&quot;defer: panic() 执行2&quot;) &#125; panic(&quot;发生异常&quot;) fmt.Println(&quot;该条语句无法执行&quot;)&#125;func main() &#123; defer_panic() fmt.Println(&quot;main函数执行完成&quot;)&#125;复制代码 结果 12345defer: panic() 执行2defer: panic() 执行1panic: 发生异常// 异常信息...复制代码 defer遇到Panic，但捕获异常的情况示例 12345678910111213141516171819202122package mainimport &quot;fmt&quot;func defer_panic() &#123; defer func() &#123; fmt.Println(&quot;defer: panic() 执行1&quot;) if err := recover(); err != nil &#123; fmt.Println(err) &#125; &#125;() defer func() &#123; fmt.Println(&quot;defer: panic() 执行2&quot;) &#125; panic(&quot;发生异常&quot;) fmt.Println(&quot;该条语句无法执行&quot;)&#125;func main() &#123; defer_panic() fmt.Println(&quot;main函数执行完成&quot;)&#125;复制代码 结果 12345defer: panic() 执行2defer: panic() 执行1发生异常main函数执行完成复制代码 练习：defer面试题1. 下面代码输出什么？ 12345678910111213package mainimport &quot;fmt&quot;func main() &#123; var name = &quot;zhangsan&quot; fmt.Println(name) defer fmt.Println(name) name = &quot;lisa&quot; fmt.Println(name) defer fmt.Println(name)&#125;复制代码 考点 12defer和函数组合调⽤方式 复制代码 结果 12zhangsan lisa lisa zhangsan 复制代码 2. 程序运行结果 示例 12345678910111213package mainimport ( &quot;fmt&quot;)func main() &#123; defer_call()&#125;func defer_call() &#123; defer func() &#123; fmt.Println(&quot;迈&quot;) &#125;() defer func() &#123; fmt.Println(&quot;莫&quot;) &#125;() defer func() &#123; fmt.Println(&quot;coding&quot;) &#125;()&#125;复制代码 考点 12defer和函数组合调⽤方式 复制代码 结果 1234coding莫迈复制代码 3. 下面代码输出什么？ 示例 1234567891011121314package mainimport &quot;fmt&quot;func DeferFunc1(i int) (t int) &#123; t = i defer func() &#123; t += 3 &#125;() return t&#125;func main() &#123; fmt.Println(DeferFunc1(1))&#125;复制代码 考点 12defer和函数组合调⽤方式 复制代码 结果 124复制代码 执行过程 123451. 将返回值t赋值为行参i，t = 12. 执行return语句，将t 赋值给t3. 执行defer语句，t + 3 = 44. 返回值4复制代码 4. 下面代码输出什么？ 示例 1234567891011121314package mainimport &quot;fmt&quot;func DeferFunc2(i int) int &#123; t := i defer func() &#123; t += 3 &#125;() return t&#125;func main() &#123; fmt.Println(DeferFunc2(1))&#125;复制代码 考点 12defer和函数组合调⽤方式 复制代码 结果 121复制代码 执行过程 123451. 创建变量t并将其赋值为i的值，t = 12. 执行return语句，注意这里是将t赋值给返回值，此时返回值为1（这个返回值并不是t）3.执行defer语句，t = t + 3 = 44. 函数返回值1复制代码 5. 下面代码输出什么？ 示例 1234567891011121314package mainimport &quot;fmt&quot;func DeferFunc3(i int) (t int) &#123; defer func() &#123; t += i &#125;() return 2&#125;func main() &#123; fmt.Println(DeferFunc3(1))&#125;复制代码 考点 12defer和函数组合调⽤方式 复制代码 结果 123复制代码 执行过程 12341. 首先将t赋值为22. 执行defer语句，t = t + 1 = 33. 函数返回值3复制代码 6. 下面代码输出什么？ 示例 123456789101112131415package mainimport &quot;fmt&quot;func DeferFunc4() (t int) &#123; defer func(i int) &#123; fmt.Println(i) fmt.Println(t) &#125;(t) t = 1 return 2&#125;func main() &#123; DeferFunc4()&#125;复制代码 考点 12defer和函数组合调⽤方式 复制代码 结果 12302复制代码 执行过程 1234567891. 初始化返回值t为零值 02. 首先执行defer的第一步，赋值defer中的func入参t为03. 执行defer的第二步，将defer压栈4. 将t赋值为15. 执行return语句，将返回值t赋值为26. 执行defer的第三步，出栈并执行7. 因为在入栈时defer执行的func的入参已经赋值了，此时它作为的是一个形式参数，所以打印为0；8. 相对应的因为最后已经将t的值修改为2，所以再打印一个2复制代码","categories":[],"tags":[{"name":"Go","slug":"Go","permalink":"http://www.fixblog.cn/tags/Go/"},{"name":"defer","slug":"defer","permalink":"http://www.fixblog.cn/tags/defer/"}]},{"title":"Go的灵魂拷问","slug":"go-basic","date":"2019-01-24T12:09:23.000Z","updated":"2021-02-24T06:51:53.440Z","comments":true,"path":"2019/01/24/go-basic/","link":"","permalink":"http://www.fixblog.cn/2019/01/24/go-basic/","excerpt":"","text":"1. defer执行顺序1234567891011func main() &#123; call()&#125;func call() &#123; defer func() &#123;fmt.Println(&quot;打印前&quot;)&#125;() defer func() &#123;fmt.Println(&quot;打印中&quot;)&#125;() defer func() &#123;fmt.Println(&quot;打印后&quot;)&#125;() panic(&quot;触发异常&quot;)&#125; 2. foreach 以下代码的问题及原因123456789101112131415type student struct &#123; Name string Age int&#125;func pase_student() &#123; m :&#x3D; make(map[string]*student) stus :&#x3D; []student&#123; &#123;Name: &quot;周&quot;, Age: 22&#125; &#123;Name: &quot;王&quot;, Age: 23&#125; &#125; for _, stu :&#x3D; range stus &#123; m[stu.Name] &#x3D; &amp;stu &#125;&#125; 3. 随机性和闭包 以下代码的输出及原因123456789101112131415161718fun main() &#123; runtime.GOMAXPROCS(1) wg :&#x3D; sync.WaitGroup&#123;&#125; wg.Add(20) for i :&#x3D; 0; i &lt; 10; i++ &#123; go func() &#123; fmt.Print(&quot;A: &quot;, i) wg.Done() &#125;() &#125; for i :&#x3D; 0; i &lt; 10; i++ &#123; go func(i int) &#123; fmt.Print(&quot;B: &quot;, i) wg.Done() &#125;(i) &#125; wg.Wait()&#125; 4.组合继承 以下代码输出什么1234567891011121314151617181920212223type People struct &#123;&#125;func (p *People) ShowA() &#123; fmt.Prinln(&quot;showA&quot;) p.ShowB()&#125;func (p *People) ShowB() &#123; fmt.Println(&quot;showB&quot;)&#125;type Teacher struct &#123; People&#125;func (t *Teacher) ShowB() &#123; fmt.Println(&quot;teacher showB&quot;)&#125;func main() &#123; t :&#x3D; Teacher&#123;&#125; t.ShowA()&#125; 5.select 随机性 下面代码会触发异常吗12345678910111213func main() &#123; runtime.GOMAXPROCS(1) int_chan :&#x3D; make(chan int, 1) string_chan :&#x3D; make(chan string, 1) int_chan &lt;- 1 string_chan &lt;- &quot;hello&quot; select &#123; case value :&#x3D; &lt;- int_chan: fmt.Println(value) case value :&#x3D; &lt;- string_chan: panic(value) &#125;&#125; 6. defer执行顺序 下面代码会输出什么1234567891011121314func calc(index string, a, b int) int &#123; ret :&#x3D; a + b fmt.Println(index, a, b, ret) return ret&#125;func main() &#123; a :&#x3D; 1 b :&#x3D; 2 defer calc(&quot;1&quot;, a, calc(&quot;10&quot;, a, b)) a &#x3D; 0 defer calc(&quot;2&quot;, a, calc(&quot;20&quot;, a, b)) b &#x3D; 1&#125; 7. make默认值及append12345func main() &#123; s :&#x3D; make([]int, 5) s &#x3D; append(s, 1,2,3) fmt.Println(s)&#125; 8. map线程安全1234567891011121314151617type UserAges struct &#123; ages map[string]int sync.Mutex&#125;func (u *UserAges) Add(name string, age int) &#123; u.Lock() defer u.Unlock() u.ages[name] &#x3D; age&#125;func (u *UserAges) Get(name string) int &#123; if age, ok :&#x3D; u.ages[name]; ok &#123; return age &#125; return -1&#125; 9. interface内部结构12345678910111213141516171819202122type People interface &#123; show()&#125;type Student struct &#123;&#125;func (stu *Student) show() &#123;&#125;func live() People &#123; var stu *Student return stu&#125;func main() &#123; if live() &#x3D;&#x3D; nil &#123; fmt.Println(&quot;AAA&quot;) &#125; else &#123; fmt.Println(&quot;BBB&quot;) &#125;&#125;","categories":[],"tags":[{"name":"Go","slug":"Go","permalink":"http://www.fixblog.cn/tags/Go/"}]},{"title":"记录docker的基本操作","slug":"docker-basic","date":"2019-01-18T02:09:06.000Z","updated":"2021-02-24T06:47:05.421Z","comments":true,"path":"2019/01/18/docker-basic/","link":"","permalink":"http://www.fixblog.cn/2019/01/18/docker-basic/","excerpt":"","text":"Docker中央仓库 1.Docker 官方的中央仓库 下载速度慢 官方镜像 2.国内的镜像网站 网易蜂巢 daoCloud 镜像的操作123# 拉取镜像到本地docker pull 镜像名称[:tag]docker pull https://hub.daocloud.io 12# 查看全部本地镜像docker images 12# 删除本地镜像docker rmi 镜像的标示 1234567# 镜像的导入导出# 将本地的命令导出docker save -o 导出的路径 镜像的ID# 加载本地的镜像文件docker load -i 镜像文件# 修改镜像名称docker tag 镜像ID 新镜像名称:版本 12345678# 清除docker镜像缓存docker system prune --volumes该命令清除：所有停止的容器所有不被任何一个容器使用的网络所有不被任何一个容器使用的volume所有无实例的镜像 容器的操作1234567# 运行容器docker run 镜像的标示 镜像名称[:tag]# 常用参数docker run -d -p 宿主机端口:容器端口 --name 容器名称 镜像标示# -d：代表后台运行容器# -p：宿主机端口:容器端口 映射宿主机端口到容器端口# --name：指定容器的名称 1234# 查看正在运行的容器docker ps [-qa]# -a：查看全部的容器 包括没有运行的# -q：只查看容器的标示 123# 查看容器日志docker logs -f 容器ID# -f：滚动查看最后几行日志 12# 进入容器内部docker exec -it 容器ID /bin/bash 1234567891011# 删除容器（需先停止容器）docker stop 容器ID# 停止全部的容器docker stop $(docker ps -qa)# 删除指定容器docker rm 容器ID# 删除全部容器docker rm $(docker ps -qa)# 启动容器docker start 容器ID 12# 将宿主机文件复制到容器内部docker cp 文件名称 容器ID:容器内路径 数据卷 将宿主机中的一个目录映射到容器中的一个目录,可以在宿主机中操作这个目录，容器中也会随着改变 123# 创建数据卷docker volume create 数据卷名称# 创建数据卷之后默认会存放在一个目录下 /var/lib/docker/volumes/数据卷名称/_data 123456# 查看数据卷的详细信息docker volume inspect 数据卷名称# 查看全部数据卷docker volume ls# 删除数据卷docker volume rm 数据卷名称 12345# 应用数据卷# 当你映射数据卷时如果不存在，docker会自动创建数据卷(会将容器内部自带的文件存储在默认的数据卷中)docker run -v 数据卷名称:容器内部的路径 镜像ID# 直接指定一个路径作为数据卷的存放位置（路径下是空的需要手动指定容器中的文件）docker run -v 路径:容器内部的路径 镜像ID Docker自定义镜像123456# 创建一个Dockerfile文件,并且指定自定义镜像信息# Dockerfile文件中常用内容from：指定当前自定义镜像依赖的环境copy：将相对路径下的内容复制到自定义镜像中workdir：声明镜像的默认工作目录cmd：需要执行的命令 (在workdir下执行的 cmd可以写多个只以最后一个为准) 123# Dockerfile文件简单例子from daocloud.io/library/tomcat:8.5.15-jre8 # 一个tomcat的镜像copy test.txt /usr/local/tomcat//webapps # 将文件复制到自定义镜像中 12# 执行Dockerfile文件制作镜像docker build -t 镜像名称:版本 . # .代表吧当前目录下的Dockerfile文件制作成镜像 Docker-Compose123456# Docker-Compose 批量管理容器 只通过compose.yml文件维护# 下载docker-composewget https://github.com/docker/compose/releases/download/1.24.1/docker-compose-Linux-x86_64# 修改文件名称加执行权限mv docker-compose-Linux-x86_64 /usr/local/bin/docker-composechmod +x docker-compose yml 文件 yml 文件以key: value方式来指定配置信息多个配置信息以换行+缩进的方式来区分docker-compose.yml禁止使用制表符，在使用docker-compose命令时 默认会在当前目录下找docker-compose.yml文件 12345678910111213141516171819202122232425version: &quot;3.1&quot;services: mysql: # 服务名称 restart: always # 代表只要docker启动那么这个容器跟着一起启动 image: daocloud.io/library/mysql:5.7.4 # 指定镜像路径 contatenr_name: mysql # 指定容器名称 ports: - 3306:3306 # 指定端口 可指定多个 - 3307:3307 environment: MYSQL_ROOT_PASSWORD: root # 指定MySql的root用户登陆密码 TZ: Asia/Shanghai # 指定时区 volumes: - /opt/docker_mysql_tomcat/mysql_data:/var/lib/mysql #将容器目录映射到宿主机路径(可多个) tomcat: restart: always # 代表只要docker启动那么这个容器跟着一起启动 image: daocloud.io/library/tomcat:8.5.15-jre8 # 指定镜像路径 contatenr_name: tomcat # 指定容器名称 ports: - 8080:8080 environment: TZ: Asia/Shanghai # 指定时区 volumes: - /opt/docker_mysql_tomcat/tomcat_webapps:/usr/local/tomcat/webapps - /opt/docker_mysql_tomcat/tomcat_logs:/usr/local/tomcat/logs 123# docker-compose.yml启动管理容器docker-compose up -d# -d：后台运行 12# 关闭并删除容器docker-compose down 12# 开启|关闭|重启已经存在的由docker-compose维护的容器docker-compose start|stop|restart 12# 查看docker-compose管理的容器docker-compose ps 12# 查看日志docker-compose logs -f docker-compose配置Dockerfile使用 使用docker-compose.yml文件以及Dockerfile文件在生成自定义镜像的同时启动当前镜像，并且由 Docker-compose去管理容器 docker-compose.yml文件 12345678910111213version: &quot;3.1&quot;services: ssm: restart: always build: # 构建自定义镜像 context: ../ # 指定Dockerfile文件路径 dockerfile: Dockerfile # 指定Dockerfile文件名称 image: ssm:1.0.1 container_name: ssm ports: - 8080:8080 environment: TZ: Asia/Shanghai Dockerfile文件 12from daocloud.io&#x2F;library&#x2F;tomcat:8.5.15-jre8copy test.txt &#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;&#x2F;webapps 1234567# 可以直接启动基于docker-compose.yml以及Dockerfile文件构建的自定义镜像docker-compose up -d# 如果自定义镜像不存在 会帮助我们构建，如果已经存在则会直接运行这个自定义镜像# 重新构建自定义镜像docker-compose build# 运行前重新构建docker-compose up -d --build","categories":[],"tags":[{"name":"docker","slug":"docker","permalink":"http://www.fixblog.cn/tags/docker/"}]},{"title":"Nginx的基本操作","slug":"nginx-basic","date":"2019-01-03T09:40:11.000Z","updated":"2021-02-24T06:45:53.317Z","comments":true,"path":"2019/01/03/nginx-basic/","link":"","permalink":"http://www.fixblog.cn/2019/01/03/nginx-basic/","excerpt":"","text":"Nginx 稳定性强，7*24小时不间断运行 Nginx提供了非常丰富的配置实例 占用内存小，并发能力强 Docker安装docker-compose.yml文件 12345678910version: &quot;3.1&quot;services: nginx: restart: always image: daocloud.io/library/nginx:latest container_name: nginx ports: - 80:80 volumes: - /opt/docker_nginx/conf.d/:/etc/nginx/conf.d 12# 执行拉取镜像docker-compose up -d 1# Nginx配置文件 12345678910111213141516171819202122232425262728293031323334user nginx;worker_processes 1;error_log /var/log/nginx/error.log warn;pid /var/run/nginx.pid;# 以上统称为全局块 worker_processes数值越大并发越强events &#123; worker_connections 1024;&#125;# events块# worker_connections他的数值越大并发越强http &#123; include /etc/nginx/mime.types; #大量的媒体类型 default_type application/octet-stream; # 默认响应的类型 log_format main &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27; &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27; &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;; access_log /var/log/nginx/access.log main; sendfile on; #tcp_nopush on; keepalive_timeout 65; #gzip on; include /etc/nginx/conf.d/*.conf;&#125; Nginx 反向代理 正向代理： 正向代理服务时由客户端设立的 客户端了解代理服务器和目标服务器都是谁 帮助实现突破访问权限，提高访问速度对目标服务器隐藏客户端的IP地址。 反向代理： 反向代理服务器是配置在服务端的。 客户端不知道到底访问的是哪一台服务器。 反向代理可以达到负载均衡，并且可以隐藏服务器真正的IP地址。 Nginx 配置反向代理： 准备一个目标服务器 修改nginx配置文件，通过nginx访问到目标服务器 1234567891011121314server&#123; listen 8000; server_name localhost; # 基于反向代理访问 location / &#123; proxy_pass http://www.fixblog.cn; &#125; #location / &#123; # root /usr/share/nginx/html; # index index.html index.htm; #&#125;&#125; Nginx的location路径映射 ​ 优先级关系： ​ (location=) &gt; (location /xxx/yyy/zzz) &gt; (location ^~)&gt;(location ~, ~*) &gt; (location /起始路径)&gt;(location /) 1234# =匹配location = / &#123; # 精确匹配,主机名后面不能带任何的字符串&#125; 1234# 通用匹配location /xxx &#123; # 匹配所有以/xxx开头的路径&#125; 1234# 正则匹配location ~ /xxx &#123; # 匹配所有以/xxx开头的路径&#125; 1234# 匹配开头路径location ^~ /images/ &#123; # 匹配所有以/images开头的路径&#125; 1234# 匹配结尾~* \\.(gif|jpg|png)$ &#123; # 匹配以gif|jpg|png为结尾的路径&#125; Nginx负载均衡 Nginx默认提供了三种负载均衡策略： 轮询： 将客户端发起的请求，平均的分配给每一台服务器。 权重： 会将客户端的请求，根据服务器的权重值不同，分配不同的数量。 IP_HASH： 只要发起请求的客户端的IP地址不变，他始终会将请求发送到指定的服务器上。 12345678910111213141516171819# 轮询方式配置负载均衡upstream my-server &#123; # server外部配置 upstream server ip:port; server ip:port;&#125;server&#123; listen 80; server_name localhost; location / &#123; proxy_pass http://my-server/; &#125; #location / &#123; # root /usr/share/nginx/html; # index index.html index.htm; #&#125;&#125; 12345678910111213141516171819# 权重方式配置负载均衡upstream my-server &#123; server ip:port weight=10; # 使用weight 配置请求的权重值 server ip:port weight=2;&#125;server&#123; listen 8000; server_name localhost; location / &#123; proxy_pass http://my-server/; &#125; #location / &#123; # root /usr/share/nginx/html; # index index.html index.htm; #&#125;&#125; 1234567891011121314151617181920# IP_HASH方式配置负载均衡upstream my-server &#123; ip_hash; # 配置ip_hash参数即可 server ip:port; server ip:port;&#125;server&#123; listen 8000; server_name localhost; location / &#123; proxy_pass http://my-server/; &#125; #location / &#123; # root /usr/share/nginx/html; # index index.html index.htm; #&#125;&#125; Nginx动静分离 Nginx的并发能力公式： ​ worker_processes * worker_connections / 4 | 2 = Nginx最终的并发能力 ​ 动态资源乘以4 静态资源乘以2 Nginx通过动静分离来提升Nginx的并发能力更快的响应 1234# 动态资源代理location / &#123; proxy_pass 路径;&#125; 123456# 静态资源代理location / &#123; root 静态资源路径; index 默认访问路径下的什么资源; autoindex on; # 代表展示静态资源的全部内容 以列表的形式展开&#125; Nginx集群 单点故障 避免nginx宕机导致整个程序的崩溃。 准备多台Nginx 和keepalived(监听Nginx的健康情况)。 准备haproxy 提供一个虚拟的路径，统一去接收用户请求。 123456789101112# Dockerfile 文件FROM nginx:1.13.5-alpine # 镜像RUN apk update &amp;&amp; apk upgrade # 更新 下载upgrade 相当于centos yum操作RUN apk add --no-cache bash curl ipvsadm iproute2 openrc keepalived # 下载COPY entrypoint.sh /entrypoint.sh # 复制脚本RUN chmod +x /entrypoint.sh # 给权限CMD [&quot;/entrypoint.sh&quot;] # 启动时运行脚本 1234567# entrypoint.sh#!/bin/sh#/usr/sbin/keepalived -n -l -D -f /etc/keepalived/keepalived.conf --dont-fork --log-console &amp;/usr/sbin/keepalived -D -f /etc/keepalived/keepalived.conf # 启动 keepalived 指定配置文件nginx -g &quot;daemon off;&quot; # 启动nginx 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# docker-compose.ymlversion: &quot;3.1&quot;services: nginx_master: build: context: ./ dockerfile: ./Dockerfile ports: - 8081:80 volumes: - ./index-master.html:/usr/share/nginx/html/index.html - ./favicon.ico:/usr/share/nginx/html/favicon.ico - ./keepalived-master.conf:/etc/keepalived/keepalived.conf networks: static-network: ipv4_address: 49.233.173.199 # docker 容器的占用的ip cap_add: # 添加一些权限 - NET_ADMIN nginx_slave: build: context: ./ dockerfile: ./Dockerfile ports: - 8082:80 volumes: - ./index-slave.html:/usr/share/nginx/html/index.html - ./favicon.ico:/usr/share/nginx/html/favicon.ico - ./keepalived-slave.conf:/etc/keepalived/keepalived.conf networks: static-network: static-network: ipv4_address: 49.233.173.199 # docker 容器的占用的ip cap_add: # 添加一些权限 - NET_ADMIN proxy: image: haproxy:1.7-alpine ports: - 6301:6301 volumes: - ./haproxy.cfg:/usr/local/etc/haproxy/haproxy.cfg networks: - static-networknetworks: static-network: ipam: config: - subnet: 49.233.173.199/16 12345678910111213141516171819202122232425# haproxy.cfgglobal log 127.0.0.1 local0 maxconn 4096 daemon nbproc 4defaults log 127.0.0.1 local3 mode http option dontlognull option redispatch retries 2 maxconn 2000 balance roundrobin timeout connect 5000ms timeout client 5000ms timeout server 5000msfrontend main bind *:6301 default_backend webserverbackend webserver server nginx_master 49.233.173.199:6301 check inter 2000 rise 2 fall 5 1234567891011121314151617181920212223242526# keepalived-master.confvrrp_script chk_nginx &#123; script &quot;pidof nginx&quot; interval 2&#125;vrrp_instance VI_1 &#123; state MASTER interface eth0 #容器内部的网卡名称 virtual_router_id 33 priority 200 # 优先级 advert_int 1 authentication &#123; auth_type PASS auth_pass letmein &#125; virtual_ipaddress &#123; 49.233.173.199 # 虚拟路径 &#125; track_script &#123; chk_nginx &#125;&#125; 1234567891011121314151617181920212223242526# keepalived-slave.confvrrp_script chk_nginx &#123; script &quot;pidof nginx&quot; interval 2&#125;vrrp_instance VI_1 &#123; state BACKUP interface eth0 #容器内部的网卡名称 virtual_router_id 33 priority 100 # 优先级 advert_int 1 authentication &#123; auth_type PASS auth_pass letmein &#125; virtual_ipaddress &#123; 49.233.173.199 # 虚拟路径 &#125; track_script &#123; chk_nginx &#125;&#125;","categories":[],"tags":[{"name":"nginx","slug":"nginx","permalink":"http://www.fixblog.cn/tags/nginx/"}]},{"title":"Centos下安装配置Redis","slug":"centos-redis","date":"2018-05-04T15:01:35.000Z","updated":"2021-02-23T10:09:37.376Z","comments":true,"path":"2018/05/04/centos-redis/","link":"","permalink":"http://www.fixblog.cn/2018/05/04/centos-redis/","excerpt":"","text":"下载1[root@bo local]# wget http:&#x2F;&#x2F;download.redis.io&#x2F;releases&#x2F;redis-4.0.9.tar.gz # 改变版本选择相应版本 1[root@bo local]# tar -zxvf redis-4.0.9.tar.gz # 解压 安装123[root@bo local]# cd &#x2F;usr&#x2F;local&#x2F;redis-4.0.9 # 进入解压的目录[root@bo local]# make MALLOC&#x3D;libc # 编译安装[root@bo local]# cd &#x2F;src &amp;&amp; make install # 将src目录下的文件添加到&#x2F;usr&#x2F;local&#x2F;bin目录下 配置12[root@bo local]# cd &#x2F;usr&#x2F;local&#x2F;redis-4.0.9&#x2F;src[root@bo local]# .&#x2F;redis-server # 启动redis 后台运行 12[root@bo local]# vim &#x2F;usr&#x2F;local&#x2F;redis-4.0.9&#x2F;redis.conf将 daemonize no 配置项修改为 daemonize yes redis后台运行 配置文件 1234在&#x2F;etc&#x2F;目录下创建redis目录[root@bo local]# mkdir &#x2F;etc&#x2F;redis将redis.conf配置文件复制一份到&#x2F;etc&#x2F;redis目录下并改名为6379.conf[root@bo local]# cp &#x2F;usr&#x2F;local&#x2F;redis-4.0.9&#x2F;redis.conf &#x2F;etc&#x2F;redis&#x2F;6379.conf 启动脚本 12将redis的启动将本复制到系统init.d目录下[root@bo local]# cp &#x2F;usr&#x2F;local&#x2F;redis-4.0.9&#x2F;utils&#x2F;redis_init_script &#x2F;etc&#x2F;init.d&#x2F;redisd 配置开机自启动 12[root@bo local]# cd &#x2F;etc&#x2F;init.d[root@bo local]# chkconfig redisd on # 执行自启命令 12redis 启动 service redisd startredis 关闭 service redisd stop","categories":[],"tags":[]},{"title":"jetbrains激活教程","slug":"jetbrains-agent","date":"2017-04-24T04:57:00.000Z","updated":"2021-02-23T08:29:54.615Z","comments":true,"path":"2017/04/24/jetbrains-agent/","link":"","permalink":"http://www.fixblog.cn/2017/04/24/jetbrains-agent/","excerpt":"","text":"此教程来源于网络只用作个人学习和分享，勿用于商业谋利 资源获取本激活方法需使用jar包以及专用激活码，获取方法见下文。 配置从官网下载对应的IDE安装完成后打开点击**Evaluate for free** 免费使用，随意创建一个空的项目使之进入到IDE的工作页面在此点击IDE菜单栏中的Help - Edit Custom VM Option... 打开此文件， 将jetbrains-agent.jar文件放到IDE安装目录的bin目录下并在此文件中配置 1-javaagent:&#x2F;Applications&#x2F;GoLand.app&#x2F;Contents&#x2F;bin&#x2F;jetbrains-agent.jar # 填写自己的路径 修改完配置文件后重启IDE！ 激活码 重启IDE后，点击菜单栏中的Help Register...进行激活 License server 方式激活 地址填写 : http://jetbrains-license-server 或点击Discover Server来填充地址激活 Activation code 方式激活 直接复制激活码激活(激活码见下文) 验证 完成激活后点击Help About 可查看IDE版本号，有效期等信息 资源 Jar 包：网盘连接 密码:ssnz License server地址：http://jetbrains-license-server 激活码 1520E5894E2-eyJsaWNlbnNlSWQiOiI1MjBFNTg5NEUyIiwibGljZW5zZWVOYW1lIjoicGlnNiIsImFzc2lnbmVlTmFtZSI6IiIsImFzc2lnbmVlRW1haWwiOiIiLCJsaWNlbnNlUmVzdHJpY3Rpb24iOiJVbmxpbWl0ZWQgbGljZW5zZSB0aWxsIGVuZCBvZiB0aGUgY2VudHVyeS4iLCJjaGVja0NvbmN1cnJlbnRVc2UiOmZhbHNlLCJwcm9kdWN0cyI6W3siY29kZSI6IklJIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUlMwIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiV1MiLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJSRCIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IlJDIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiREMiLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJEQiIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IlJNIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiRE0iLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJBQyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkRQTiIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkdPIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUFMiLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJDTCIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IlBDIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUlNVIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In1dLCJoYXNoIjoiODkwNzA3MC8wIiwiZ3JhY2VQZXJpb2REYXlzIjowLCJhdXRvUHJvbG9uZ2F0ZWQiOmZhbHNlLCJpc0F1dG9Qcm9sb25nYXRlZCI6ZmFsc2V9-DZ&#x2F;oNHBfyho0XrrCJJvAOKg5Q1tLBgOdbCmzCKwkuM+Yryce0RoOi3OOmH6Ba&#x2F;uTcCh&#x2F;L37meyD0FJdJIprv59y4+n+k2kIeF&#x2F;XKrKqg0dEsDUQRw0lUqqMt99ohqa+zmbJ44Yufdwwx&#x2F;F1CtoRGvEQ2Mn0QjuqRoZJZ3wiT5Am22JiJW8MaNUl3wg9YPj+OPGARKKJUdUJ0NGUDQBcBAv5ds8LhbSbJSbPkbkwH&#x2F;a1QMz4nEdn6lRDKI1aFIn43QhBSCFqvUq6TPJlbIJ0ZjE+PyZjHFBKCgkry0DHPXU2BbtIZPsksQnN3fx240a9K6sN7peZnLpEoMoq23FEz4g&#x3D;&#x3D;-MIIElTCCAn2gAwIBAgIBCTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE4MTEwMTEyMjk0NloXDTIwMTEwMjEyMjk0NlowaDELMAkGA1UEBhMCQ1oxDjAMBgNVBAgMBU51c2xlMQ8wDQYDVQQHDAZQcmFndWUxGTAXBgNVBAoMEEpldEJyYWlucyBzLnIuby4xHTAbBgNVBAMMFHByb2QzeS1mcm9tLTIwMTgxMTAxMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA5ndaik1GD0nyTdqkZgURQZGW+RGxCdBITPXIwpjhhaD0SXGa4XSZBEBoiPdY6XV6pOfUJeyfi9dXsY4MmT0D+sKoST3rSw96xaf9FXPvOjn4prMTdj3Ji3CyQrGWeQU2nzYqFrp1QYNLAbaViHRKuJrYHI6GCvqCbJe0LQ8qqUiVMA9wG&#x2F;PQwScpNmTF9Kp2Iej+Z5OUxF33zzm+vg&#x2F;nYV31HLF7fJUAplI&#x2F;1nM+ZG8K+AXWgYKChtknl3sW9PCQa3a3imPL9GVToUNxc0wcuTil8mqveWcSQCHYxsIaUajWLpFzoO2AhK4mfYBSStAqEjoXRTuj17mo8Q6M2SHOcwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl&#x2F;GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQBonMu8oa3vmNAa4RQP8gPGlX3SQaA3WCRUAj6Zrlk8AesKV1YSkh5D2l+yUk6njysgzfr1bIR5xF8eup5xXc4&#x2F;G7NtVYRSMvrd6rfQcHOyK5UFJLm+8utmyMIDrZOzLQuTsT8NxFpbCVCfV5wNRu4rChrCuArYVGaKbmp9ymkw1PU6+HoO5i2wU3ikTmRv8IRjrlSStyNzXpnPTwt7bja19ousk56r40SmlmC04GdDHErr0ei2UbjUua5kw71Qn9g02tL9fERI2sSRjQrvPbn9INwRWl5+k05mlKekbtbu2ev2woJFZK4WEXAd&#x2F;GaAdeZZdumv8T2idDFL7cAirJwcrbfpawPeXr52oKTPnXfi0l5+g9Gnt&#x2F;wfiXCrPElX6ycTR6iL3GC2VR4jTz6YatT4Ntz59&#x2F;THOT7NJQhr6AyLkhhJCdkzE2cob&#x2F;KouVp4ivV7Q3Fc6HX7eepHAAF&#x2F;DpxwgOrg9smX6coXLgfp0b1RU2u&#x2F;tUNID04rpNxTMueTtrT8WSskqvaJd3RH8r7cnRj6Y2hltkja82HlpDURDxDTRvv+krbwMr26SB&#x2F;40BjpMUrDRCeKuiBahC0DCoU&#x2F;4+ze1l94wVUhdkCfL0GpJrMSCDEK+XEurU18Hb7WT+ThXbkdl6VpFdHsRvqAnhR2g4b+Qzgidmuky5NUZVfEaZqV&#x2F;g&#x3D;&#x3D; 此方法对 **jetbrains**系列产品有效","categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://www.fixblog.cn/tags/php/"}]},{"title":"mysql事物","slug":"mysql-transaction","date":"2017-04-12T03:17:13.000Z","updated":"2021-02-23T08:30:16.717Z","comments":true,"path":"2017/04/12/mysql-transaction/","link":"","permalink":"http://www.fixblog.cn/2017/04/12/mysql-transaction/","excerpt":"","text":"MySql版本链1对于使用InnoDB存储引擎的表来说它的聚簇索引记录中都包含两个必要的隐藏列(row_id并不是必要的，我们创建的表中有主键或者非NULL唯一建时都不会包含row_id列) trx_id:每次对某条记录进行改变时，都会把对应的事物ID赋值给trx_id隐藏列 roll_pointer:每次对某条记录进行改变时，这个隐藏列会存一个指针，可以通过这个指针找到该记录修改前的信息 MySql ReadView1对于使用READ UNCOMMITTED 隔离级别的事物来说直接读取记录的最新版本就好了,对于使用SERIALIZABLE 隔离级别的事物来说使用加锁的方式来访问记录，对于使用READ COMMITTEDD和REPEATABLE READ 隔离级别的事物来说就需要用到版本链了，核心问题就是需要判断以下版本链中的那个版本是当前事物中可见的。 m_ids：表示在生成ReadView时当前系统中活跃的(没有提交的)读写事物的事物ID列表 min_trx_id：表示在生成ReadView时当前系统中活跃的读写事物中最小的事物ID也就是m_ids中的最小值 max_trx_id：表示在生成ReadView时系统中应该分配给写一个事物ID的值 creator_trx_id：表示生成该ReadView的事物ID MySql 隔离级别 查看当前会话的隔离级别 1select @@tx_isolation; Mysql8 改为 transaction_isolation参数 查看系统当前隔离级别 1select @@global.tx_isolation; 设置当前会话隔离级别 1MySql8以下 set session transaction isolatin level repeatable read; 设置系统当前隔离级别 1set global transaction isolation level repeatable read; 关于隔离级别的理解12read uncommitted 读未提交一个事物可以读到其他事物还未提交的数据，例如:SESSION_A的操作还未提交但是SESSION_B就可以看到SESSION_A操作的结果 这种现象为(脏读) 123read committed 读提交 不可重复读一个事物只能读到另一个已经提交的事物修改过的数据,可能多次读取的数据结果不一致如果一个事物先根据某些条件查询出一些记录，之后另一个事物又向表中写入了符合这些条件的记录,原来的事物再次按照该条件查询时能把另一个事物写入的记录也读出来(幻读) 12repeatable read 可重复读SESSION_A第一次读过某条记录后即使SESSION_B修改了该记录的值并提交SESSION_A之后再去读这条记录时读到的任然是第一次读到的值这种隔离级别解决了不可重复但还是会出现幻读。 123serializable 串行化串行化不允许读-写，写-读的并发操作，这种隔离级别对同一条记录的操作是串行的，所以不会出现脏读，幻读等现象。例如：SESSION_A要读 SESSION_B要写 而SESSION_B只有等SESSION_A事物完成并提交后才能对当前记录的操作，中间会有阻塞的现象。 总结 READ UNCOMMITTED 隔离级别下，可能发生脏读 ，不可重复读，幻读的问题。 READ COMMITTED 隔离级别下，可能发生不可重复读和幻读的问题，但不会发生脏读的问题 REPEATABLE READ 隔离级别下，可能发生幻读，不会发生脏读和不可重复读的问题。 SERIALIZABLE 隔离级别下，各种问题都不可以发生。 注意：这四种隔离级别是SQL的标准定义，不同的数据库会有不同的实现，特别需要注意的是 MySql在REPEATABLE READ隔离级别下是可以禁止幻读问题的发生。","categories":[],"tags":[]},{"title":"Centos7下安装MySql8","slug":"centos-mysql","date":"2017-04-05T08:58:22.000Z","updated":"2021-02-23T08:27:30.043Z","comments":true,"path":"2017/04/05/centos-mysql/","link":"","permalink":"http://www.fixblog.cn/2017/04/05/centos-mysql/","excerpt":"","text":"下载进入官网下载自己合适的MySql8安装包 12mysql-8.0.15-el7-x86_64.tar.gz 上传至服务器中解压 tar -zxvf mysql-8.0.15-el7-x86_64.tar.gz 安装将解压后的目录移动到/usr/local/ 并修改目录名为mysql 1mv mysql-8.0.15-el7-x86_64.tar.gz &#x2F;usr&#x2F;local&#x2F;mysql 添加mysql 运行用户和组 12添加mysql组 groupadd mysql添加mysql用户并加入到mysql组中 useradd -r -g mysql mysql 修改mysql为 mysql 组和mysql用户 1chown -R mysql:mysql &#x2F;usr&#x2F;local&#x2F;mysql 初始化配置，会产生临时密码需记住用来第一次登陆 12进入mysql目录 cd &#x2F;usr&#x2F;local&#x2F;mysql初始化 bin&#x2F;mysqld --initialize --user&#x3D;mysql --basedir&#x3D;&#x2F;usr&#x2F;local&#x2F;mysql -- datadir&#x3D;&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;data 查看是否有生成my.cnf配置文件 12进入&#x2F;etc目录 cd &#x2F;etcls | grep my.cnf 如果没有自动生成/etc/my.cnf 则手动创建一个 12创建my.cnf配置文件 touch &#x2F;etc&#x2F;my.cnf修改权限 chmod 755 &#x2F;etc&#x2F;my.cnf 配置编辑my.cnf配置文件 1234567[mysqld]basedir&#x3D;&#x2F;usr&#x2F;local&#x2F;mysql # mysql目录datadir&#x3D;&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;data # mysql数据目录port&#x3D;3306 # mysql端口socket&#x3D;&#x2F;tmp&#x2F;mysql.sock # mysql的套接字pid-file&#x3D;&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;$hostname.pid # $hostname为主机名称sql_mode&#x3D;NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES 配置mysql环境变量 1234vim &#x2F;etc&#x2F;profile # 打开profile文件export MYSQL_HOME MYSQL_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;mysqlexport PATH&#x3D;$PATH:$MYSQL_HOME&#x2F;lib:$MYSQL_HOME&#x2F;bin保存后 source &#x2F;etc&#x2F;profile 让配置生效 配置mysql开机启动项 1234cp &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;support-files&#x2F;mysql.server &#x2F;etc&#x2F;init.d&#x2F;mysql加执行权限 chmod +x &#x2F;etc&#x2F;init.d&#x2F;mysql注册启动服务 chkconfig --add mysql查看启动服务 chkconfig --list 启动123启动 service mysql start停止 service mysql stop重启 service mysql restart 使用初始化是生成的密码登陆 12mysql -u root -pPassword: evoeJ%b13d0h 修改新的密码 1alter user &#39;root&#39;@&#39;localhost&#39; identified by &#39;your_password&#39;;","categories":[],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://www.fixblog.cn/tags/mysql/"}]},{"title":"consul配置","slug":"consul","date":"2017-03-22T07:02:01.000Z","updated":"2021-02-23T09:55:50.695Z","comments":true,"path":"2017/03/22/consul/","link":"","permalink":"http://www.fixblog.cn/2017/03/22/consul/","excerpt":"","text":"官网 https://www.consul.io/downloads.html 集群启动 12345consul agent -server -bootstrap-expect=3 -data-dir=/var/consul -node=node-172.16.4.49 -bind=172.16.4.49 -client=0.0.0.0 -datacenter=BeiJing -uiconsul agent -server -bootstrap-expect=3 -data-dir=/var/consul -node=node-172.16.4.50 -bind=172.16.4.50 -client=0.0.0.0 -datacenter=BeiJing -uiconsul agent -server -bootstrap-expect=3 -data-dir=/var/consul -node=node-172.16.4.53 -bind=172.16.4.53 -client=0.0.0.0 -datacenter=BeiJing -ui 参数说明 server： 以server身份启动。默认是client bootstrap-expect：集群要求的最少server数量，当低于这个数量，集群即失效。 data-dir：data存放的目录，更多信息请参阅consul数据同步机制 node：节点id，集群中的每个node必须有一个唯一的名称。默认情况下，Consul使用机器的hostname bind：监听的ip地址。默认绑定0.0.0.0，可以不指定。表示Consul监听的地址,而且它必须能够被集群中的其他节点访问。Consul默认会监听第一个private IP,但最好还是提供一个。生产设备上的服务器通常有好几个网卡，所以指定一个不会出错 client: 客户端的ip地址，0.0.0.0是指谁都可以访问（不加这个，下面的ui :8500无法访问） ui: 可以访问UI界面 -config-dir指定配置文件夹，Consul会加载其中的所有文件 -datacenter 指定数据中心名称，默认是dc1 组成consul集群 12# 将另外两台机器加入到172.16.4.49consul join 172.16.4.49 集群状态 1consul operator raft list-peers 服务注册 123方法：PUT请求：http://127.0.0.1:8500/v1/agent/service/register参数：application/json 12345678910111213141516171819202122&#123; &quot;ID&quot;: &quot;os_snmp-v3&quot;, &quot;Name&quot;: &quot;snmp-v3&quot;, &quot;Tags&quot;: [&quot;snmp&quot;, &quot;v3&quot;], &quot;Address&quot;: &quot;172.16.2.177&quot;, &quot;Port&quot;: 8888, &quot;EnableTagOverride&quot;: false, &quot;Check&quot;: &#123; // 健康检查 &quot;Notes&quot;: &quot;Ensure we don&#x27;t oversubscribe memory&quot;, &quot;DeregisterCriticalServiceAfter&quot;: &quot;服务注销时间秒 如果服务异常时&quot;, &quot;Args&quot;: [&quot;指定要运行的命令参数以更新检查状态&quot;], &quot;DockerContainerID&quot;: &quot;指定检查是Docker检查&quot;, &quot;HTTP&quot;: &quot;http检查模式&quot;, &quot;Method&quot;: &quot;http检查方式 默认GET&quot;, &quot;Header&quot;: &#123; &quot;Content-Type&quot;: [&quot;指定一组应为HTTP检查设置的标题&quot;] &#125;, &quot;Body&quot;: &quot;&#123;指定应与HTTP支票一起发送的正文。&#125;&quot;, &quot;TCP&quot;: &quot;指定TCP以每个值连接TCP&quot;, &quot;Interval&quot;: &quot;指定运行此检查的频率&quot;, &quot;Timeout&quot;: &quot;在脚本，HTTP，TCP或gRPC检查的情况下，指定传出连接的超时&quot;, &quot;TLSSkipVerify&quot;: &quot;指定是否不验证HTTPS检查的证书。(布尔值)&quot; &#125;&#125;","categories":[],"tags":[]},{"title":"Linux搭建GitLab服务器","slug":"git-lab","date":"2017-03-22T07:02:01.000Z","updated":"2021-02-23T08:29:08.707Z","comments":true,"path":"2017/03/22/git-lab/","link":"","permalink":"http://www.fixblog.cn/2017/03/22/git-lab/","excerpt":"","text":"GitLab简介 GitLab 是利用 Ruby On Rails 一个开源的版本管理系统，实现一个自托管的 Git 项目仓库，可通过 Web 界面进行访问公开的或者私人项目。它拥有与 GitHub 类似的功能，能够浏览源代码，管理缺陷和注释。可以管理团队对仓库的访问，它非常易于浏览提交过的版本并提供一个文件历史库。团队成员可以利用内置的简单聊天程序( Wall )进行交流。它还提供一个代码片段收集功能可以轻松实现代码复用，便于日后有需要的时候进行查找。 资料 官方:https://about.gitlab.com/downloads/#ubuntu1404 国内镜像:https://mirror.tuna.tsinghua.edu.cn/help/gitlab-ce/ 安装和配置必要的依赖 如果你安装 postfix 发送邮件，如果你不需要邮件发送,可以跳过直接看第二步,请选择“网站设置”中。而不是使用后缀也可以使用道具或配置自定义 SMTP 服务器和它配置为 SMTP 服务器。在 CentOS 的6和7，下面的命令将在系统防火墙打开 HTTP 和 SSH 访问。 1sudo apt-get install curl openssh-server ca-certificates postfix 切换清华大学镜像 首先信任 GitLab 的 GPG 公钥: 1curl https:&#x2F;&#x2F;packages.gitlab.com&#x2F;gpg.key 2&gt; &#x2F;dev&#x2F;null | sudo apt-key add - &amp;&gt;&#x2F;dev&#x2F;null 选择你的 Debian/Ubuntu 版本， 其他版本请跳转国内镜像查看/etc/apt/sources.list.d/gitlab-ce.list 这个文件默认不存在 你需要创建并添加下面配置 12vim &#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;gitlab-ce.list 加入以下内容deb https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;gitlab-ce&#x2F;ubuntu trusty main 添加完成执行更新 并安装gitlab 12sudo apt-get update sudo apt-get install gitlab-ce ####配置文件和修改域名 123&#x2F;etc&#x2F;gitlab&#x2F;gitlab.rb修改 &#x2F;etc&#x2F;gitlab&#x2F;gitlab.rb文件external_url &#39;你的域名&#39; ####配置邮箱 12345678910111213#Sending application email via SMTPgitlab_rails[&#39;smtp_enable&#39;] &#x3D; true gitlab_rails[&#39;smtp_address&#39;] &#x3D; &quot;smtp.163.com&quot; gitlab_rails[&#39;smtp_port&#39;] &#x3D; 25 gitlab_rails[&#39;smtp_user_name&#39;] &#x3D; &quot;xxuser@163.com&quot; gitlab_rails[&#39;smtp_password&#39;] &#x3D; &quot;xxpassword&quot; gitlab_rails[&#39;smtp_domain&#39;] &#x3D; &quot;163.com&quot; gitlab_rails[&#39;smtp_authentication&#39;] &#x3D; :login gitlab_rails[&#39;smtp_enable_starttls_auto&#39;] &#x3D; true##修改 gitlab 配置的发信人gitlab_rails[&#39;gitlab_email_from&#39;] &#x3D; &quot;xxuser@163.com&quot; user[&quot;git_user_email&quot;] &#x3D; &quot;xxuser@163.com&quot; 如果执行不成功 请检查配置和内存 gitlab-ctl reconfigure 重新编译启动 文档地址 apt-get 安装默认集成了 nginx 如果你需要服务器在跑其他环境,你需要修改你的gitlab nginx 的端口 12vim &#x2F;etc&#x2F;gitlab&#x2F;gitlab.rbnginx[&#39;listen_port&#39;] &#x3D; 8080 可使用 gitlab-ctl help 查看更多命令","categories":[],"tags":[]},{"title":"phpstorm-速查表","slug":"phpstorm-quick-check-list","date":"2017-03-17T06:40:44.000Z","updated":"2021-02-23T08:30:53.864Z","comments":true,"path":"2017/03/17/phpstorm-quick-check-list/","link":"","permalink":"http://www.fixblog.cn/2017/03/17/phpstorm-quick-check-list/","excerpt":"","text":"Mac基本按键说明123456⌘——Command⌃ ——Control⌥——Option/Alt⇧——Shift⇪——Caps Lockfn——功能键就是fn 快捷调试1234Control+alt+R 运行项目 Command+Control+R 运行Debug Command+F8 添加断点 Command+shift+F8 打开断点列表 编辑功能1234567891011121314151617181920212223242526Command+alt+T 用 (if..else, try..catch, for, etc.)包住 Command+&#x2F; 注释&#x2F;取消注释的行注释 Command+alt+&#x2F; 注释&#x2F;取消注释与块注释 alt+↑ 向上选取代码块 alt+↓ 向下选取代码块 Command+alt+L 格式化代码 tab,shift+tab 调整缩进 Control+alt+I 快速调整缩进 Command+C 复制 Command+X 剪切 Command+V 粘贴 Command+shift+V 从剪贴板里选择粘贴 Command+D 复制代码副本 Command+delete 删除当前行 Control+Shift+J 清除缩进变成单行 shift+回车 快速换行 Command+回车 换行光标还在原先位置 Command+shift+U 大小写转换 Command+shift+[,Command+shift+] 文件选项卡快速切换 Command+加号,Command+减号 收缩代码块 Command+shift+加号，Command+shift+减号 收缩整个文档的代码块 Command+W 关闭当前文件选项卡 alt+单击 光标在多处定位 Control+shift+J 把下面行的缩进收上来 shift + F6 高级修改，可快速修改光标所在的标签、变量、函数等 alt+&#x2F; 代码补全 定点导航123456789101112131415161718192021Command+O 跳转到某个类 Command+shift+O 跳转到某个文件 Command+alt+O 跳转到某个符号 Control+←,Control+→ 转到上&#x2F;下一个编辑器选项卡 F12 打开之前打开的工具窗口（TODO、终端等） Command+L 跳转行 Command+E 弹出最近文件 Command+alt+←,Command+alt+→ 向前向后导航到代码块交接处（一般是空行处） Command+shift+delete 导航到上一个编辑位置的位置 Command+B 跳转到变量声明处 Control+J 获取变量相关信息（类型、注释等，注释是拿上一行的注释） Command+Y 小浮窗显示变量声明时的行 Command+[,Command+] 光标现在的位置和之前的位置切换 Command+F12 文件结构弹出式菜单 alt+H 类的层次结构 F2,shift+F2 切换到上\\下一个突出错误的位置 Command+↑ 跳转到导航栏 F3 添加书签 alt+F3 添加带助记的书签 alt+1,alt+2… 切换到相应助记的书签位置 Command+F3 打开书签列表 VCS/本地历史记录1234control+V 打开VST小浮窗 Command+K 提交项目 Command+T 更新项目 alt+shift+C 打开最近修改列表 搜索和替换123456Command+F 搜索 Command+R 替换 Command+G 查找下一个 Command+shift+G 查找下一个 Command+shift+F 按路径搜索 Command+shift+R 按路径替换 选中文字的搜索123Command+F7 向声明的地方搜索并选中 Command+shift+F7 打开搜索框进行搜索 Command+alt+F7 打开小浮窗显示搜索列表 对项目文件的操作1234F5 复制文件到某个目录 F6 移动文件到某个目录 Command+delete 安全删除 shift+F6 重命名 全局快捷键12345678910双击shift 弹出小浮窗搜索所有Command+~切换项目 Command+shift+~ 反向切换项目 (在打开的不同项目中切换) Command+shift+A 整个工程的查找操作 Command+1,Command+2… 打开各种工具窗口 alt+shift+F 把文件添加到收藏夹 alt+shift+I 打开项目描述 alt+~ 快速切换当前计划 Command+, 设置编辑器 Control+Tab 选项卡和工具窗口之间进行切换 alert+回车 显示npm版本升级列表","categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://www.fixblog.cn/tags/php/"}]},{"title":"记录Hexo博客的搭建","slug":"centos-hexo","date":"2017-02-03T07:42:07.000Z","updated":"2021-02-23T08:27:10.021Z","comments":true,"path":"2017/02/03/centos-hexo/","link":"","permalink":"http://www.fixblog.cn/2017/02/03/centos-hexo/","excerpt":"","text":"简介记录在Centos系统上搭建Hexo博客框架,实现简单的个人博客。(本次记录客户端以Mac os为例,服务端以阿里云ECS为例) Hexo介绍 Hexo是一个快速、简洁且高效的博客框架。Hexo使用Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。Hexo使用Node.js来渲染页面，因此渲染速度极快。只需一条指令即可部署到 GitHub Pages, Heroku 或其他网站。同时，Hexo 拥有强大的插件系统，安装插件可以让 Hexo 支持 Jade, CoffeeScript。 准备 Git For Mac Git For Win Nodejs For Mac Nodejs For Win Nginx 下载对应版本 客户端配置 安装Git及配置 Mac下直接下载后缀为.pkg的Git文件进行傻瓜式安装即可,安装完成后可查看版本确认 12author$ git versionauthor$ git version 2.15.0 配置用户名及邮箱 12author$ git config --global user.name &quot;用户名&quot;author$ git config --global user.email &quot;邮箱&quot; 确认是否生成SSH Key 1author$ ls ~&#x2F;.ssh 如果没有SSH Key 则创建一个 1author$ ssh-keygen -t rsa -C &quot;邮箱&quot; 安装Nodejs 下载后缀为.pkg的Nodejs安装文件进行安装即可，安装完成后可查看node和npm版本确认 12author$ node -vv12.14.1 12author$ npm -v6.13.4 安装Hexo框架 直接通过npm来全局安装Hexo框架 1author$ npm install -g hexo-cli 漫长的等待完成Hexo框架安装之后再进行初始化，选择一个目录来存放博客文件 12author$ cd fixblogauthor$ hexo init blog #初始化 初始化完成以后打开blog目录下的package.json文件，在dependencies的配置项中追加Git选项，然后使用npm进行包的安装。 12author$ cd blogauthor$ vi package.json 1author$ npm install 包安装完成以后可直接启动博客然后在浏览器通过localhost:4000进行访问Hexo博客默认页面了 12author$ cd blogauthor$ hexo s 至此在客户端的Hexo框架安装及相关配置就完成了 服务端配置 安装Nginx Centos下安装使用yum安装或者到官网下载源码安装即可安装完成后通过IP访问出现以下页面表示安装成功 在Nginx安装目录下的vhost目录下新建后缀为.conf的配置文件来配置域名及博客目录 12author$ cd &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;vhostauthor$ touch fixblog.cn.conf 在新建的fixblog.cn.conf配置文件中配置以下信息 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748server &#123; #listen [::]:80 default_server ipv6only&#x3D;on; server_name www.fixblog.cn fixblog.cn; #域名 index index.php index.html index.htm; root &#x2F;home&#x2F;wwwroot&#x2F;blog; #博客目录 #error_page 404 &#x2F;404.html; # Deny access to PHP files in specific directory #location ~ &#x2F;(wp-content|uploads|wp-includes|images)&#x2F;.*\\.php$ &#123; deny all; &#125; include enable-php.conf; location &#x2F;nginx_status &#123; stub_status on; access_log off; &#125; location &#x2F; &#123; if (!-e $request_filename) &#123; rewrite ^(.*)$ &#x2F;index.php?s&#x3D;&#x2F;$1 last; break; &#125; #try_files $uri $uri&#x2F; &#x2F;index.php?$query_string; &#125; location ~ .*\\.(gif|jpg|jpeg|png|bmp|swf)$ &#123; expires 30d; &#125; location ~ .*\\.(js|css)?$ &#123; expires 12h; &#125; location ~ &#x2F;.well-known &#123; allow all; &#125; location ~ &#x2F;\\. &#123; deny all; &#125; access_log &#x2F;home&#x2F;wwwlogs&#x2F;access.log; &#125; 至此，Nginx的配置基本完成了。 安装Nodejs Centos下可直接使用yum来安装Nodejs，安装完成后检查nodejs和npm版本信息 123author$ yum install -y nodejsauthor$ node -vauthor$ npm -v 安装Git及配置 Centos下可直接使用yum来安装Git，安装完成后检查Git版本信息 12author$ yum install gitauthor$git version 创建git用户及密码 12author$ adduser gitauthor$ passwd git 把git用户添加到sudo用户组当中 1author$ vi &#x2F;etc&#x2F;sudoers 切换到git用户并将客户端生成SSH Key的公钥加入到服务器~/.ssh/authorized_keys文件中 12author$ su gitauthor$ vi ~&#x2F;.ssh&#x2F;authorized_keys #将客户端的公钥加入到此文件 12author$ chmod 600 ~&#x2F;.ssh&#x2F;authorized_keys # 添加权限author$ chmod 700 ~&#x2F;.ssh 配置完成后返回客户端测试是否可以连接 1author$ ssh -v git@serverIp 创建Nginx所配置的博客目录 /home/wwwroot/blog 并授予git用户 12author$ sudo mkdir -p &#x2F;home&#x2F;wwwroot&#x2F;blog # 创建博客目录author$ sudo chown -R git:git &#x2F;home&#x2F;wwwroot&#x2F;blog 在服务器上初始化一个git裸仓库并创建一个post-receive文件给予执行权限 1234567author$ su git # 切换git用户author$ cd ~ # 进入当前用户的家目录author$ git init --bare blog.gitauthor$ vim ~&#x2F;blog.git&#x2F;hooks&#x2F;post-receive # 新建post-receive文件加入以下内容#！&#x2F;bin&#x2F;shgit --work-tree&#x3D;&#x2F;博客目录路径&#x2F; --git-dir&#x3D;&#x2F;初始化git仓库路径&#x2F; checkout -f 1author$ chmod +x ~&#x2F;blog.git&#x2F;hooks&#x2F;post-receive #赋予执行权限 返回客户端配置博客根目录下的 _config.yml文件，配置Git提交地址。 12345deploy: type: &#39;git&#39; repo: git@serverIp:&#x2F;home&#x2F;git&#x2F;fixblog.git # 服务器初始化的git仓库地址 branch: master message: 保存后使用以下命令测试 123hexo clean # 清除hexo博客缓存hexo g # 重新生成博客静态文件hexo d # 将hexo博客推送到服务器 以上命令都正常执行后就可通过Nginx中配置的域名访问博客了。","categories":[],"tags":[{"name":"linux hexo","slug":"linux-hexo","permalink":"http://www.fixblog.cn/tags/linux-hexo/"}]},{"title":"GIT简介","slug":"git","date":"2016-05-21T06:34:23.000Z","updated":"2021-02-23T08:31:38.456Z","comments":true,"path":"2016/05/21/git/","link":"","permalink":"http://www.fixblog.cn/2016/05/21/git/","excerpt":"","text":"使用GIT在本地创建一个项目 $ mkdir ~/hello-world //创建一个项目hello-world$ cd ~/hello-world //打开这个项目$ git init //初始化$ touch README$ git add README //更新README文件$ git commit -m ‘first commit’ //提交更新，并注释信息“first commit”$ git remote add origin &#103;&#105;&#116;&#x40;&#103;&#x69;&#116;&#x68;&#117;&#x62;&#46;&#x74;&#x65;&#115;&#x74;/hellotest.git //连接远程github项目$ git push -u origin master //将本地项目更新到github项目上去 git设置关闭自动换行 $ git config –global core.autocrlf false 为了保证文件的换行符是以安全的方法，避免windows与unix的换行符混用的情况，最好也加上这么一句 $ git config –global core.safecrlf true git tag 使用 git tag # 列出当前仓库的所有标签git tag -l ‘v0.1.*’ # 搜索符合当前模式的标签git tag v0.2.1-light # 创建轻量标签git tag -a v0.2.1 -m ‘0.2.1版本’ # 创建附注标签git checkout [tagname] # 切换到标签git show v0.2.1 # 查看标签版本信息git tag -d v0.2.1 # 删除标签git tag -a v0.2.1 9fbc3d0 # 补打标签git push origin v0.1.2 # 将v0.1.2标签提交到git服务器git push origin –tags # 将本地所有标签一次性提交到git服务器git tag # 查看当前分支下的标签 git pull问题 You asked me to pull without telling me which branch youwant to merge with, and ‘branch.content_api_zhangxu.merge’ inyour configuration file does not tell me, either. Pleasespecify which branch you want to use on the command line andtry again (e.g. ‘git pull ‘).See git-pull(1) for details.If you often merge with the same branch, you may want touse something like the following in your configuration file: [branch “content_api_zhangxu”] remote = merge = [remote ““] url = fetch = See git-config(1) for details.git pull origin new_branch 怎样遍历移除项目中的所有 .pyc 文件 sudo find /tmp -name “*.pyc” | xargs rm -rf 替换/tmp目录为工作目录 git rm *.pyc git变更项目地址 git remote set-url origin &#x67;&#105;&#116;&#x40;&#49;&#x39;&#50;&#46;&#x31;&#x36;&#x38;&#x2e;&#54;&#46;&#x37;&#48;:res_dev_group/test.gitgit remote -v 查看某个文件的修改历史 git log –pretty=oneline 文件名 # 显示修改历史git show 356f6def9d3fb7f3b9032ff5aa4b9110d4cca87e # 查看更改 git push 时报错 warning: push.default is unset‘matching’ 参数是 Git 1.x 的默认行为，其意是如果你执行 git push 但没有指定分支，它将 push 所有你本地的分支到远程仓库中对应匹配的分支。而 Git 2.x 默认的是 simple，意味着执行 git push 没有指定分支时，只有当前分支会被 push 到你使用 git pull 获取的代码。根据提示，修改git push的行为: git config –global push.default matching 再次执行git push 得到解决 git submodule的使用拉子项目代码开发过程中，经常会有一些通用的部分希望抽取出来做成一个公共库来提供给别的工程来使用，而公共代码库的版本管理是个麻烦的事情。今天无意中发现了git的git submodule命令，之前的问题迎刃而解了 git submodule add 仓库地址 路径 其中，仓库地址是指子模块仓库地址，路径指将子模块放置在当前工程下的路径。注意：路径不能以 / 结尾（会造成修改不生效）、不能是现有工程已有的目录（不能順利 Clone） 命令执行完成，会在当前工程根路径下生成一个名为“.gitmodules”的文件，其中记录了子模块的信息。添加完成以后，再将子模块所在的文件夹添加到工程中即可。 submodule的删除稍微麻烦点：首先，要在“.gitmodules”文件中删除相应配置信息。然后，执行git rm –cached命令将子模块所在的文件从git中删除。 下载的工程带有submodule 当使用git clone下来的工程中带有submodule时，初始的时候，submodule的内容并不会自动下载下来的，此时，只需执行如下命令： git submodule update –init –recursive 即可将子模块内容下载下来后工程才不会缺少相应的文件。 git add文件取消在git的一般使用中，如果发现错误的将不想提交的文件add进入index之后，想回退取消，则可以使用命令 git reset HEAD …git reset（回退add操作） git删除文件删除文件跟踪并且删除文件系统中的文件file1 git rm file1 提交刚才的删除动作，之后git不再管理该文件 git commit 删除文件跟踪但不删除文件系统中的文件 file1git rm –cached file1 提交刚才的删除动作，之后git不再管理该文件，但是文件系统中还是有file1 git commit 版本回退版本回退用于线上系统出现问题后恢复旧版本的操作，回退到的版本。 git reset –hard 248cba8e77231601d1189e3576dc096c8986ae51 回退的是所有文件，如果后悔回退可以git pull就可以了。 历史版本对比查看日志git log查看某一历史版本的提交内容，这里能看到版本的详细修改代码。 git show 4ebd4bbc3ed321d01484a4ed206f18ce2ebde5ca 分支的意义与管理创建分支可以避免提交代码后对主分支的影响，同时也使你有了相对独立的开发环境。分支具有很重要的意义。创建并切换分支，提交代码后才能在其它机器拉分支代码 git checkout -b new_branch 查看当前分支 git branch 切换到master分支 git checkout master 合并分支到当前分支，合并分支的操作是从new_branch合并到master分支，当前环境在master分支。 git merge new_branch 删除分支 git branch -d new_branch git冲突文件编辑冲突文件冲突的地方如下面这样 冲突标记&lt;&lt;&lt;&lt;&lt;&lt;&lt; （7个&lt;）与=======之间的内容是我的修改，=======与&gt;&gt;&gt;&gt;&gt;&gt;&gt;之间的内容是别人的修改。此时，还没有任何其它垃圾文件产生。 git顺利的提交代码流程查看修改的文件 git status 为了谨慎检查一下代码 git diff 添加修改的文件，新加的文件也是直接add就好了你需要把代码合并好后重新走一遍代码提交流程就好了。 git add dirname1/filename1.py dirname2/filenam2.py 添加修改的日志 git commit -m “fixed:修改了上传文件的逻辑” 提交代码git push，如果提交失败的可能原因是本地代码库版本不是最新。 创建和使用git ssh key首先设置git的user name和email git config –global user.name “xxx”git config –global user.email “&#120;&#x78;&#120;&#64;&#x67;&#x6d;&#97;&#105;&#x6c;&#46;&#99;&#x6f;&#109;“ 查看git配置 git config –list 然后生成SHH密匙查看是否已经有了ssh密钥：cd ~/.ssh如果没有密钥则不会有此文件夹，有则备份删除生成密钥 ssh-keygen -t rsa -C “&#x61;&#117;&#116;&#104;&#x7a;&#106;&#64;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d;“ 按3个回车，密码为空这里一般不使用密钥。最后得到了两个文件：id_rsa和id_rsa.pub注意：密匙生成就不要改了，如果已经生成到~/.ssh文件夹下去找。","categories":[],"tags":[]},{"title":"PHP的错误机制总结","slug":"error","date":"2016-04-26T12:15:46.000Z","updated":"2021-02-23T08:28:54.620Z","comments":true,"path":"2016/04/26/error/","link":"","permalink":"http://www.fixblog.cn/2016/04/26/error/","excerpt":"","text":"PHP的错误机制也是非常复杂的，做了几年php，也没有仔细总结过，现在就补上这一课。 特别说明：文章的PHP版本使用5.5.32 PHP的错误级别首先需要了解php有哪些错误。截至到php5.5，一共有16个错误级别 注意：尝试下面的代码的时候请确保打开error_log: error_reporting(E_ALL);ini_set(‘display_errors’, ‘On’); E_ERROR这种错误是致命错误，会在页面显示Fatal Error， 当出现这种错误的时候，程序就无法继续执行下去了 错误示例： // Fatal error: Call to undefined function hpinfo() in /tmp/php/index.php on line 5hpinfo(); //E_ERROR注意，如果有未被捕获的异常，也是会触发这个级别的。 E_WARNING这种错误只是警告，不会终止脚本，程序还会继续进行，显示的错误信息是Warning。比如include一个不存在的文件。 //Warning: include(a.php): failed to open stream: No such file or directory in &gt; &gt; &gt; /tmp/php/index.php on line 7//Warning: include(): Failed opening ‘a.php’ for inclusion &gt;&gt;(include_path=’.:/usr/share/pear:/usr/share/php’) in /tmp/php/index.php on line 7include(“a.php”); //E_WARNING E_NOTICE这种错误程度更为轻微一些，提示你这个地方不应该这么写。这个也是运行时错误，这个错误的代码可能在其他地方没有问题，只是在当前上下文情况下出现了问题。 比如$b变量不存在，我们把它赋值给另外一个变量 //Notice: Undefined variable: b in /tmp/php/index.php on line 9$a = $b; //E_NOTICE E_PARSE这个错误是编译时候发生的，在编译期发现语法错误，不能进行语法分析。 比如下面的z没有设置为变量。 // Parse error: syntax error, unexpected ‘=’ in /tmp/php/index.php on line 20z=1; // E_PARSE E_STRICT这个错误是PHP5之后引入的，你的代码可以运行，但是不是PHP建议的写法。比如在函数形参传递++符号 // Strict Standards: Only variables should be passed by reference in /tmp/php/index.php on &gt; line 17function change (&amp;$var) {$var += 10; } $var = 1; change(++$var); // E_STRICT E_RECOVERABLE_ERROR这个级别其实是ERROR级别的，但是它是期望被捕获的，如果没有被错误处理捕获，表现和E_ERROR是一样的。经常出现在形参定义了类型，但调用的时候传入了错误类型。它的错误提醒也比E_ERROR的fatal error前面多了一个Catachable的字样。 //Catchable fatal error: Argument 1 passed to testCall() must be an instance of A, instance of B given, called in /tmp/php/index.php on line 37 and defined in /tmp/php/index.php on line 33class A {}class B {}function testCall(A $a) {}$b = new B();testCall($b); E_DEPRECATED这个错误表示你用了一个旧版本的函数，而这个函数后期版本可能被禁用或者不维护了。比如curl的CURLOPT_POSTFIELDS使用@FILENAME来上传文件的方法 // Deprecated: curl_setopt(): The usage of the @filename API for file uploading is deprecated. Please use the CURLFile class instead in /tmp/php/index.php on line 42$ch = curl_init(“http://www.remotesite.com/upload.php&quot;);curl_setopt($ch, CURLOPT_POSTFIELDS, array(‘fileupload’ =&gt; ‘@’. “test”)); E_CORE_ERROR, E_CORE_WARNING这两个错误是由PHP的引擎产生的，在PHP初始化过程中发生。 E_COMPILE_ERROR, E_COMPILE_WARNING这两个错误是由PHP引擎产生的，在编译过程中发生。 E_USER_ERROR, E_USER_WARNING, E_USER_NOTICE, E_USER_DEPRECATED,这些错误都是用户制造的，使用trigger_error，这里就相当于一个口子给用户触发出各种错误类型。这个是一个很好逃避try catch异常的方式。 trigger_error(“Cannot divide by zero”, E_USER_ERROR);// E_USER_ERROR// E_USER_WARING// E_USER_NOTICE// E_USER_DEPRECATED E_ALLE_STRICT出外的所有错误和警告信息。 错误控制php中有很多配置和参数是可以控制错误，以及错误的日志显示的。第一步，我们需要了解的是php中的有关错误的配置有哪些？我们按照php+php-fpm的模型来说，会影响php错误显示的其实是有两个配置文件，一个是php本身的配置文件php.ini，另外一个是php-fpm的配置文件，php-fpm.conf。 php.ini中的配置 error_reporting = E_ALL // 报告错误级别，什么级别的error_log = /tmp/php_errors.log // php中的错误显示的日志位置display_errors = On // 是否把错误展示在输出上，这个输出可能是页面，也可能是stdoutdisplay_startup_errors = On // 是否把启动过程的错误信息显示在页面上，记得上面说的有几个Core类型的错误是启动时候发生的，这个就是控制这些错误是否显示页面的。log_errors = On // 是否要记录错误日志log_errors_max_len = 1024 // 错误日志的最大长度ignore_repeated_errors = Off // 是否忽略重复的错误track_errors = Off // 是否使用全局变量$php_errormsg来记录最后一个错误xmlrpc_errors = 0 //是否使用XML-RPC的错误信息格式记录错误xmlrpc_error_number = 0 // 用作 XML-RPC faultCode 元素的值。html_errors = On // 是否把输出中的函数等信息变为HTML链接docref_root = http://manual/en/ // 如果html_errors开启了，这个链接的根路径是什么fastcgi.logging = 0 // 是否把php错误抛出到fastcgi中 我们经常会被问到，error_reporting和display_errors有什么区别呢？这两个函数是完全不一样的。 PHP默认是会在日志和标准输出（如果是fpm模式标准输出就是页面） error_reporting的参数是错误级别。表示什么样子的级别才应该触发错误。如果我们告诉PHP，所有错误级别都不需要触发错误，那么，不管是日志，还是页面，都不会显示这个错误，就相当于什么都没有发生。 display_errors是控制是否要在标准输出展示错误信息log_errors则是控制是否要在日志中记录错误信息。 error_log是显示错误日志的位置，这个在php-fpm中往往会被重写，于是往往会发现的是cli和fpm的错误日志竟然不是在同一个文件中。 ignore_repeated_errors这个标记控制的是如果有重复的日志，那么就只会记录一条，比如下面的程序： error_reporting(E_ALL);ini_set(‘ignore_repeated_errors’, 1);ini_set(‘ignore_repeated_source’, 1);$a = $c; $a = $c; //E_NOTICE//Notice: Undefined variable: c in /tmp/php/index.php on line 20 本来会出现两次NOTICE的，但是现在，只会出现一次了… track_errors开启会把最后一个错误信息存储到变量里面去，这个可能在对记日志的时候会有一些用处吧。不过我觉得真是没啥用… html_errors 和 docref_root 两个是个挺有人性化的配置，配置了这两个参数以后，我们返回的错误信息中如果有一些在文档中有的信息，就会变成链接形式。 error_reporting(E_ALL);ini_set(‘html_errors’, 1);ini_set(‘docref_root’, “https://secure.php.net/manual/zh/&quot;);include(“a2.php”); //E_WARNING 能让你快速定位到我们出现错误的地方。是不是很人性～ php-fpm中的配置 error_log = /var/log/php-fpm/error.log // php-fpm自身的日志log_level = notice // php-fpm自身的日志记录级别php_flag[display_errors] = off // 覆盖php.ini中的某个配置变量，可被程序中的ini_set覆盖php_value[display_errors] = off // 同php_flagphp_admin_value[error_log] = /tmp/www-error.log // 覆盖php.ini中的某个配置变量，不可被程序中的ini_set覆盖php_admin_flag[log_errors] = on // 同php_admin_valuecatch_workers_output = yes // 是否抓取fpmworker的输出request_slowlog_timeout = 0 // 慢日志时长slowlog = /var/log/php-fpm/www-slow.log // 慢日志记录 php-fpm的配置中也有一个error_log配置，这个很经常会和php.ini中的error_log配置弄混。但他们记录的东西是不一样的，php-fpm的error_log只记录php-fpm本身的日志，比如fpm启动，关闭。 而php.ini中的error_log是记录php程序本身的错误日志。 那么在php-fpm中要覆盖php.ini中的error_log配置，就需要使用到下面几个函数： php_flag php_value php_admin_flag php_admin_value 这四个函数admin的两个函数说明这个变量设置完之后，不能在代码中使用ini_set把这个变量重新赋值了。而php_flag/value就仍然以php代码中的ini_set为准。 slowlog是fpm记录的，可以使用request_slowlog_timeout设置判断慢日志的时长。","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"redis","slug":"redis","permalink":"http://www.fixblog.cn/tags/redis/"},{"name":"Go","slug":"Go","permalink":"http://www.fixblog.cn/tags/Go/"},{"name":"defer","slug":"defer","permalink":"http://www.fixblog.cn/tags/defer/"},{"name":"docker","slug":"docker","permalink":"http://www.fixblog.cn/tags/docker/"},{"name":"nginx","slug":"nginx","permalink":"http://www.fixblog.cn/tags/nginx/"},{"name":"php","slug":"php","permalink":"http://www.fixblog.cn/tags/php/"},{"name":"mysql","slug":"mysql","permalink":"http://www.fixblog.cn/tags/mysql/"},{"name":"linux hexo","slug":"linux-hexo","permalink":"http://www.fixblog.cn/tags/linux-hexo/"}]}